#!/usr/bin/python

import sys
import os

from clang.cindex import Index, CursorKind, TypeKind

def resolvetype(t, is_pointer=False, isret=False):
    if t.get_declaration().kind != CursorKind.NO_DECL_FOUND:
        t = t.get_declaration().type

    if t.kind == TypeKind.RECORD:
        return repr(t.get_declaration().spelling)
    if t.kind == TypeKind.ENUM:
        return repr(t.get_declaration().spelling)
    if t.kind == TypeKind.TYPEDEF:
        assert t.get_declaration().kind == CursorKind.TYPEDEF_DECL

        if t.get_declaration().spelling == "uint64_t":
            return "ctypes.c_uint64"
        elif t.get_declaration().spelling == "size_t":
            return "ctypes.c_size_t"

        # if the typedef is in specified file use the typedef name
        fname = t.get_declaration().location.file.name
        if fname.startswith(os.environ.get("PROJ_SRC_ROOT")) and not fname.endswith("stddef.h"):
            if is_pointer and t.get_canonical().kind == (TypeKind.POINTER):
                return "c_object_p"
            else:
                return repr(t.get_declaration().spelling)

        # otherwise use the canonical type
        return resolvetype(t.get_canonical(), is_pointer, isret)
    if t.kind == TypeKind.POINTER:
        pt = t.get_pointee()
        if pt.kind == TypeKind.CHAR_S:
            if isret:
                return "ctypes.POINTER(ctypes.c_char)"
            return "ctypes.c_char_p"
        if pt.kind == TypeKind.VOID:
            return "ctypes.c_void_p"
        return "ctypes.POINTER(%s)" % resolvetype(pt, True, isret)
    if t.kind == TypeKind.UINT:
        return "ctypes.c_uint"
    if t.kind == TypeKind.INT:
        return "ctypes.c_int"
    if t.kind == TypeKind.ULONGLONG:
        return "ctypes.c_ulonglong"
    if t.kind == TypeKind.LONGLONG:
        return "ctypes.c_longlong"
    if t.kind == TypeKind.DOUBLE:
        return "ctypes.c_double"
    if t.kind == TypeKind.BOOL:
        return "ctypes.c_bool"
    if t.kind == TypeKind.VOID:
        return "None"
    if t.kind == TypeKind.UCHAR:
        return "ctypes.c_ubyte" ## Is uchar always same as ubyte?
    if t.kind == TypeKind.DECAYED:
        return resolvetype(t.get_decayed_decayed_type(), is_pointer, isret)

    return "UNKNOWN(%s)" % t.kind

def func(tu):
    print "function_declarations = {"
    for d in tu.cursor.get_children():
        if ((d.kind != CursorKind.FUNCTION_DECL) or
            (not d.location.file) or
            (d.location.file.name not in files) or
            d.type.kind != TypeKind.FUNCTIONPROTO):
            continue
        args = [x for x in d.type.argument_types()]
        ret = d.type.get_result()

        print "    '%s': (%s," % (d.spelling, resolvetype(ret, True, True))
        print "     %s    [%s])," % (" "*len(d.spelling), ", ".join(map(resolvetype, args)))

    print "}"
    print

def enum(tu):
    print "enum_declarations = {"
    for d in tu.cursor.get_children():
        if not d.location.file or d.location.file.name not in files:
            continue


        if d.kind == CursorKind.ENUM_DECL and d.spelling:
            name = d.spelling
            print "    '%s': {" % name
            for entry in d.get_children():
                print "     %s   %s: %d," % (" "*len(name), repr(entry.spelling), entry.enum_value)
            print "    },"
            print

        if d.kind == CursorKind.TYPEDEF_DECL:
            if not d.type.get_canonical().kind == TypeKind.ENUM:
                continue
            c = list(d.get_children())
            if not c:
                continue
            assert len(c) == 1
            entry = c[0]

            if entry.kind == CursorKind.ENUM_DECL:
                name = d.spelling
                print "    '%s': {" % name
                for entry in entry.get_children():
                    print "     %s   %s: %d," % (" "*len(name), repr(entry.spelling), entry.enum_value)
                print "    },"
                print
    print "}"
    print

def parse():
    index = Index.create()
    tu = index.parse(None, sys.argv[1:])

    for diag in tu.diagnostics:
        if diag.location.file:
            fn = diag.location.file.name
        else:
            fn = "???"
        print >>sys.stderr, "Warning: %s:%d: %s" % (fn, diag.location.line, diag.spelling)

    return tu

files = list(str(x) for x in sys.argv[1:] if str(x)[0] != '-')
fname = os.path.basename(files[0])

print """#===-- Generated python interface definitions for '%s' %s===#
#
#                     The LLVM Compiler Infrastructure
#
# This file is distributed under the University of Illinois Open Source
# License. See LICENSE.TXT for details.
#
#===------------------------------------------------------------------------===#
#
# This file is automatically generated by 'generate-from-includes.py',
# do not edit manually.
#
#===-----------------------------------------------------------------------====#
""" % (fname, "-" * (23-len(fname)))
print "import ctypes"
print "from ..common import c_object_p"
print

tu = parse()
func(tu)
enum(tu)
